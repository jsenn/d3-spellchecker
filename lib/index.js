// Generated by CoffeeScript 1.6.3
(function() {
  var alphabet, bindfunc, correct, correction, cross, data, duration, edits1, edits2, height, known, setx, show, svg, unique, update, width,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  d3.json('wordlist.json', function(err, json) {
    if (err != null) {
      console.warn(err);
    }
    return window.NWORDS = json;
  });

  alphabet = 'abcdefghijklmnopqrstuvwxyz';

  unique = function(xs) {
    return xs.filter(function(x, i) {
      return (xs.indexOf(x)) === i;
    });
  };

  cross = function(xs, ys) {
    var pairs, x, y, _i, _j, _len, _len1;
    pairs = [];
    for (_i = 0, _len = xs.length; _i < _len; _i++) {
      x = xs[_i];
      for (_j = 0, _len1 = ys.length; _j < _len1; _j++) {
        y = ys[_j];
        pairs.push([x, y]);
      }
    }
    return pairs;
  };

  edits1 = function(word) {
    var a, b, crossed, deletes, i, inserts, letter, replaces, sp, splits, switches;
    splits = (function() {
      var _i, _ref, _results;
      _results = [];
      for (i = _i = 0, _ref = word.length; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        _results.push([word.slice(0, i), word.slice(i)]);
      }
      return _results;
    })();
    crossed = cross(splits, alphabet);
    deletes = (function() {
      var _i, _len, _ref, _results;
      _results = [];
      for (_i = 0, _len = splits.length; _i < _len; _i++) {
        _ref = splits[_i], a = _ref[0], b = _ref[1];
        if (b) {
          _results.push(a + b.slice(1));
        }
      }
      return _results;
    })();
    inserts = (function() {
      var _i, _len, _ref, _results;
      _results = [];
      for (_i = 0, _len = crossed.length; _i < _len; _i++) {
        _ref = crossed[_i], sp = _ref[0], letter = _ref[1];
        _results.push(sp[0] + letter + sp[1]);
      }
      return _results;
    })();
    switches = (function() {
      var _i, _len, _ref, _results;
      _results = [];
      for (_i = 0, _len = splits.length; _i < _len; _i++) {
        _ref = splits[_i], a = _ref[0], b = _ref[1];
        if (b.length > 1) {
          _results.push(a + b[1] + b[0] + b.slice(2));
        }
      }
      return _results;
    })();
    replaces = (function() {
      var _i, _len, _ref, _results;
      _results = [];
      for (_i = 0, _len = crossed.length; _i < _len; _i++) {
        _ref = crossed[_i], sp = _ref[0], letter = _ref[1];
        if (letter) {
          _results.push(sp[0] + letter + sp[1].slice(1));
        }
      }
      return _results;
    })();
    return unique(deletes.concat(switches.concat(replaces.concat(inserts))));
  };

  known = function(words) {
    var word, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = words.length; _i < _len; _i++) {
      word = words[_i];
      if (word in NWORDS) {
        _results.push(word);
      }
    }
    return _results;
  };

  edits2 = function(word) {
    var e1;
    return known((function() {
      var _i, _len, _ref, _results;
      _ref = edits1(word);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        e1 = _ref[_i];
        _results.push(edits1(e1));
      }
      return _results;
    })());
  };

  correct = function(word) {
    var corrections, count, e1, e2, maxval, maxword, w, _i, _len, _ref, _ref1;
    e1 = known(edits1(word));
    if (e1.length) {
      corrections = e1;
    } else {
      e2 = edits2(word);
      corrections = e2.length ? e2 : [word];
    }
    _ref = [null, -Infinity], maxword = _ref[0], maxval = _ref[1];
    for (_i = 0, _len = corrections.length; _i < _len; _i++) {
      w = corrections[_i];
      count = NWORDS[w];
      if (count > maxval) {
        _ref1 = [w, count], maxword = _ref1[0], maxval = _ref1[1];
      }
    }
    return (maxword || corrections[0]).split('');
  };

  width = 960;

  height = 250;

  duration = 750;

  data = [];

  setx = function(d, i) {
    return i * 32;
  };

  svg = d3.select('body').append('svg').attr('width', width).attr('height', height).append('g').attr('transform', "translate(32, " + (height / 2) + ")");

  update = function() {
    var char;
    char = String.fromCharCode(d3.event.keyCode).toLowerCase();
    switch (false) {
      case char !== '\b':
        data.pop();
        return show();
      case char !== '\r':
        data = correct(data.join(''));
        return correction();
      case __indexOf.call(alphabet, char) < 0:
        data.push(char);
        return show();
    }
  };

  show = function() {
    var text;
    svg.selectAll('text').remove();
    text = svg.selectAll('text').data(data);
    text.attr('x', setx);
    return text.enter().append('text').attr('x', setx).text(function(d) {
      return d;
    });
  };

  correction = function() {
    var text;
    text = svg.selectAll('text').data(data, bindfunc);
    text.attr('class', 'update').transition().duration(duration).attr('x', setx);
    text.enter().append('text').attr('class', 'enter').attr('y', -60).attr('x', setx).style('fill-opacity', 0).text(function(d) {
      return d;
    }).transition().duration(duration).attr('y', 0).style('fill-opacity', 1);
    return text.exit().attr('class', 'exit').attr('y', 0).transition().duration(duration).attr('y', 60).style('fill-opacity', 0).remove();
  };

  bindfunc = function(d, i) {
    var count;
    count = (data.filter(function(letter) {
      return letter === d;
    })).length;
    if (count > 1) {
      return d + i;
    } else {
      return d;
    }
  };

  d3.select('body').on('keydown', function() {
    if (d3.event.keyCode === 8) {
      d3.event.preventDefault();
    }
    return update();
  });

}).call(this);
